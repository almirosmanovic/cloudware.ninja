<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Cloudware ninja</title>
        <link>/posts/</link>
        <description>Recent content in Posts on Cloudware ninja</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>Almir Osmanovic</copyright>
        <lastBuildDate>Tue, 01 Oct 2019 00:18:07 +0200</lastBuildDate>
        <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Firecracker and HA kubeadm</title>
            <link>/posts/3-post/</link>
            <pubDate>Tue, 01 Oct 2019 00:18:07 +0200</pubDate>
            
            <guid>/posts/3-post/</guid>
            <description>Run kubeadm in HA mode with Ignite VMs This short guide shows you how to setup Kubernetes in HA mode with Ignite VMs.
NOTE: At the moment, you need to execute all these commands as root.
NOTE: This guide assumes you have no running containers, in other words, that the IP of the first docker container that will be run is 172.17.0.2. You can check this with docker run --rm busybox ip addr.</description>
            <content type="html"><![CDATA[

<p><img src="https://github.com/firecracker-microvm/firecracker/raw/master/docs/images/fc_logo_full_white-bg.png" alt="Firecracker Logo Title" /></p>

<h2 id="run-kubeadm-in-ha-mode-with-ignite-vms">Run kubeadm in HA mode with Ignite VMs</h2>

<p>This short guide shows you how to setup Kubernetes in HA mode with Ignite VMs.</p>

<p><strong>NOTE:</strong> At the moment, you need to execute all these commands as <code>root</code>.</p>

<p><strong>NOTE:</strong> This guide assumes you have no running containers, in other words, that
the IP of the first docker container that will be run is <code>172.17.0.2</code>. You can check
this with <code>docker run --rm busybox ip addr</code>.</p>

<p>First set up some files and certificates using <code>prepare.sh</code> from this directory:</p>

<pre><code class="language-bash">./prepare.sh
</code></pre>

<p>This will create a kubeadm configuration file, generate the CA cert, give you a kubeconfig file, etc.</p>

<h3 id="start-the-seed-master">Start the seed master</h3>

<p>For the bootstap master, copy over the CA cert and key to use, and the kubeadm config file:</p>

<pre><code class="language-bash">ignite run weaveworks/ignite-kubeadm:latest \
    --cpus 2 \
    --memory 1GB \
    --ssh \
    --copy-files $(pwd)/run/config.yaml:/kubeadm.yaml \
    --copy-files $(pwd)/run/pki/ca.crt:/etc/kubernetes/pki/ca.crt \
    --copy-files $(pwd)/run/pki/ca.key:/etc/kubernetes/pki/ca.key \
    --name master-0
</code></pre>

<p>Initialize it with <code>kubeadm</code> using <code>ignite exec</code>:</p>

<pre><code class="language-bash">ignite exec master-0 kubeadm init --config /kubeadm.yaml --upload-certs
</code></pre>

<h3 id="join-additional-masters">Join additional masters</h3>

<p>Create more master VMs, but copy only the variables we need for joining:</p>

<pre><code class="language-bash">for i in {1..2}; do
    ignite run weaveworks/ignite-kubeadm:latest \
        --cpus 2 \
        --memory 1GB \
        --ssh \
        --copy-files $(pwd)/run/k8s-vars.sh:/etc/profile.d/02-k8s.sh \
        --name master-${i}
done
</code></pre>

<p>Use <code>ignite exec</code> to join each VM to the control plane:</p>

<pre><code class="language-bash">for i in {1..2}; do
    ignite exec master-${i} kubeadm join firekube.luxas.dev:6443 \
        --token ${TOKEN} \
        --discovery-token-ca-cert-hash sha256:${CA_HASH} \
        --certificate-key ${CERT_KEY} \
        --control-plane
done
</code></pre>

<h3 id="set-up-a-haproxy-loadbalancer-locally">Set up a HAProxy loadbalancer locally</h3>

<pre><code class="language-bash">docker run -d -v $(pwd)/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg -p 6443:443 haproxy:alpine
</code></pre>

<h3 id="use-kubectl">Use kubectl</h3>

<p>This will make <code>kubectl</code> talk to any of the three masters you&rsquo;ve set up, via HAproxy.</p>

<pre><code class="language-bash">export KUBECONFIG=$(pwd)/run/admin.conf

kubectl get nodes
</code></pre>

<p>Right now it&rsquo;s expected that the nodes are in state <code>NotReady</code>, as CNI networking isn&rsquo;t set up.</p>

<h4 id="install-a-cni-network-weave-net">Install a CNI Network &ndash; Weave Net</h4>

<p>We&rsquo;re going to use <a href="https://github.com/weaveworks/weave">Weave Net</a>.</p>

<pre><code class="language-bash">kubectl apply -f https://git.io/weave-kube-1.6
</code></pre>

<p>With this, the nodes should transition into the <code>Ready</code> state in a minute or so.</p>

<h3 id="watch-the-cluster-heal">Watch the cluster heal</h3>

<p>Kill the bootstrap master and see the cluster recover:</p>

<pre><code class="language-bash">ignite rm -f master-0

kubectl get nodes
</code></pre>

<p>What&rsquo;s happening underneath here is that HAproxy (or any other loadbalancer) notices that
<code>master-0</code> is unhealthy, and removes it from the roundrobin list. etcd also realizes
that one peer is lost, and re-elects a leader amongst the two that are still standing.</p>
]]></content>
        </item>
        
        <item>
            <title>Create a Cluster with a Fargate Task Using the AWS CLI</title>
            <link>/posts/second-post/</link>
            <pubDate>Tue, 01 Oct 2019 00:10:07 +0200</pubDate>
            
            <guid>/posts/second-post/</guid>
            <description>The following steps help you set up a cluster, register a task definition, run a task, and perform other common scenarios in Amazon ECS with the AWS CLI. Ensure that you are using the latest version of the AWS CLI. For more information on how to upgrade to the latest version, see Installing the AWS Command Line Interface.
Topics + Prerequisites + Step 1: (Optional) Create a Cluster + Step 2: Register a Task Definition + Step 3: List Task Definitions + Step 4: Create a Service + Step 5: List Services + Step 6: Describe the Running Service</description>
            <content type="html"><![CDATA[

<p>The following steps help you set up a cluster, register a task definition, run a task, and perform other common scenarios in Amazon ECS with the AWS CLI. Ensure that you are using the latest version of the AWS CLI. For more information on how to upgrade to the latest version, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/installing.html">Installing the AWS Command Line Interface</a>.</p>

<p><strong>Topics</strong>
+ <a href="#AWSCLI_prereq">Prerequisites</a>
+ <a href="#AWSCLI_create_cluster">Step 1: (Optional) Create a Cluster</a>
+ <a href="#AWSCLI_register_task_definition">Step 2: Register a Task Definition</a>
+ <a href="#AWSCLI_list_task_definitions">Step 3: List Task Definitions</a>
+ <a href="#AWSCLI_create_service">Step 4: Create a Service</a>
+ <a href="#AWSCLI_list_services">Step 5: List Services</a>
+ <a href="#AWSCLI_describe_service">Step 6: Describe the Running Service</a></p>

<h2 id="prerequisites-a-name-awscli-prereq-a">Prerequisites<a name="AWSCLI_prereq"></a></h2>

<p>This tutorial assumes that the following prerequisites have been completed:
+ The latest version of the AWS CLI is installed and configured. For more information about installing or upgrading your AWS CLI, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/installing.html">Installing the AWS Command Line Interface</a>.
+ The steps in <a href="get-set-up-for-amazon-ecs.md">Setting Up with Amazon ECS</a> have been completed.
+ Your AWS user has the required permissions specified in the <a href="security_iam_id-based-policy-examples.md#first-run-permissions">Amazon ECS First Run Wizard Permissions</a> IAM policy example.
+ You have a VPC and security group created to use. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/create-public-private-vpc.html">Tutorial: Creating a VPC with Public and Private Subnets for Your Clusters</a>.</p>

<h2 id="step-1-optional-create-a-cluster-a-name-awscli-create-cluster-a">Step 1: (Optional) Create a Cluster<a name="AWSCLI_create_cluster"></a></h2>

<p>By default, your account receives a <code>default</code> cluster.</p>

<p><strong>Note</strong><br />
The benefit of using the <code>default</code> cluster that is provided for you is that you don&rsquo;t have to specify the <code>--cluster cluster_name</code> option in the subsequent commands. If you do create your own, non-default, cluster, you must specify <code>--cluster cluster_name</code> for each command that you intend to use with that cluster.</p>

<p>Create your own cluster with a unique name with the following command:</p>

<pre><code>aws ecs create-cluster --cluster-name fargate-cluster
</code></pre>

<p>Output:</p>

<pre><code>{
    &quot;cluster&quot;: {
        &quot;status&quot;: &quot;ACTIVE&quot;, 
        &quot;statistics&quot;: [], 
        &quot;clusterName&quot;: &quot;fargate-cluster&quot;, 
        &quot;registeredContainerInstancesCount&quot;: 0, 
        &quot;pendingTasksCount&quot;: 0, 
        &quot;runningTasksCount&quot;: 0, 
        &quot;activeServicesCount&quot;: 0, 
        &quot;clusterArn&quot;: &quot;arn:aws:ecs:region:aws_account_id:cluster/fargate-cluster&quot;
    }
}
</code></pre>

<h2 id="step-2-register-a-task-definition-a-name-awscli-register-task-definition-a">Step 2: Register a Task Definition<a name="AWSCLI_register_task_definition"></a></h2>

<p>Before you can run a task on your ECS cluster, you must register a task definition. Task definitions are lists of containers grouped together. The following example is a simple task definition that creates a PHP web app. For more information about the available task definition parameters, see <a href="task_definitions.md">Amazon ECS Task Definitions</a>.</p>

<pre><code>{
    &quot;family&quot;: &quot;sample-fargate&quot;, 
    &quot;networkMode&quot;: &quot;awsvpc&quot;, 
    &quot;containerDefinitions&quot;: [
        {
            &quot;name&quot;: &quot;fargate-app&quot;, 
            &quot;image&quot;: &quot;httpd:2.4&quot;, 
            &quot;portMappings&quot;: [
                {
                    &quot;containerPort&quot;: 80, 
                    &quot;hostPort&quot;: 80, 
                    &quot;protocol&quot;: &quot;tcp&quot;
                }
            ], 
            &quot;essential&quot;: true, 
            &quot;entryPoint&quot;: [
                &quot;sh&quot;,
		&quot;-c&quot;
            ], 
            &quot;command&quot;: [
                &quot;/bin/sh -c \&quot;echo '&lt;html&gt; &lt;head&gt; &lt;title&gt;Amazon ECS Sample App&lt;/title&gt; &lt;style&gt;body {margin-top: 40px; background-color: #333;} &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div style=color:white;text-align:center&gt; &lt;h1&gt;Amazon ECS Sample App&lt;/h1&gt; &lt;h2&gt;Congratulations!&lt;/h2&gt; &lt;p&gt;Your application is now running on a container in Amazon ECS.&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;' &gt;  /usr/local/apache2/htdocs/index.html &amp;&amp; httpd-foreground\&quot;&quot;
            ]
        }
    ], 
    &quot;requiresCompatibilities&quot;: [
        &quot;FARGATE&quot;
    ], 
    &quot;cpu&quot;: &quot;256&quot;, 
    &quot;memory&quot;: &quot;512&quot;
}
</code></pre>

<p>The above example JSON can be passed to the AWS CLI in two ways: You can save the task definition JSON as a file and pass it with the <code>--cli-input-json file://path_to_file.json</code> option. Or, you can escape the quotation marks in the JSON and pass the JSON container definitions on the command line as in the below example. If you choose to pass the container definitions on the command line, your command additionally requires a <code>--family</code> parameter that is used to keep multiple versions of your task definition associated with each other.</p>

<p>To use a JSON file for container definitions:</p>

<pre><code>aws ecs register-task-definition --cli-input-json file://$HOME/tasks/fargate-task.json
</code></pre>

<p>The register-task-definition returns a description of the task definition after it completes its registration.</p>

<pre><code>{
    &quot;taskDefinition&quot;: {
        &quot;status&quot;: &quot;ACTIVE&quot;, 
        &quot;networkMode&quot;: &quot;awsvpc&quot;, 
        &quot;family&quot;: &quot;sample-fargate&quot;, 
        &quot;placementConstraints&quot;: [], 
        &quot;requiresAttributes&quot;: [
            {
                &quot;name&quot;: &quot;com.amazonaws.ecs.capability.docker-remote-api.1.18&quot;
            }, 
            {
                &quot;name&quot;: &quot;ecs.capability.task-eni&quot;
            }
        ], 
        &quot;cpu&quot;: &quot;256&quot;, 
        &quot;compatibilities&quot;: [
            &quot;EC2&quot;, 
            &quot;FARGATE&quot;
        ], 
        &quot;volumes&quot;: [], 
        &quot;memory&quot;: &quot;512&quot;, 
        &quot;requiresCompatibilities&quot;: [
            &quot;FARGATE&quot;
        ], 
        &quot;taskDefinitionArn&quot;: &quot;arn:aws:ecs:region:aws_account_id:task-definition/sample-fargate:2&quot;, 
        &quot;containerDefinitions&quot;: [
            {
                &quot;environment&quot;: [], 
                &quot;name&quot;: &quot;fargate-app&quot;, 
                &quot;mountPoints&quot;: [], 
                &quot;image&quot;: &quot;httpd:2.4&quot;, 
                &quot;cpu&quot;: 0, 
                &quot;portMappings&quot;: [
                    {
                        &quot;protocol&quot;: &quot;tcp&quot;, 
                        &quot;containerPort&quot;: 80, 
                        &quot;hostPort&quot;: 80
                    }
                ], 
                &quot;entryPoint&quot;: [
                    &quot;sh&quot;, 
                    &quot;-c&quot;
                ], 
                &quot;command&quot;: [
                    &quot;/bin/sh -c \&quot;echo '&lt;html&gt; &lt;head&gt; &lt;title&gt;Amazon ECS Sample App&lt;/title&gt; &lt;style&gt;body {margin-top: 40px; background-color: #333;} &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div style=color:white;text-align:center&gt; &lt;h1&gt;Amazon ECS Sample App&lt;/h1&gt; &lt;h2&gt;Congratulations!&lt;/h2&gt; &lt;p&gt;Your application is now running on a container in Amazon ECS.&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;' &gt;  /usr/local/apache2/htdocs/index.html &amp;&amp; httpd-foreground\&quot;&quot;
                ], 
                &quot;essential&quot;: true, 
                &quot;volumesFrom&quot;: []
            }
        ], 
        &quot;revision&quot;: 2
    }
}
</code></pre>

<h2 id="step-3-list-task-definitions-a-name-awscli-list-task-definitions-a">Step 3: List Task Definitions<a name="AWSCLI_list_task_definitions"></a></h2>

<p>You can list the task definitions for your account at any time with the list-task-definitions command. The output of this command shows the <code>family</code> and <code>revision</code> values that you can use together when calling run-task or start-task.</p>

<pre><code>aws ecs list-task-definitions
</code></pre>

<p>Output:</p>

<pre><code>{
    &quot;taskDefinitionArns&quot;: [
        &quot;arn:aws:ecs:region:aws_account_id:task-definition/sample-fargate:1&quot;, 
        &quot;arn:aws:ecs:region:aws_account_id:task-definition/sample-fargate:2&quot;
    ]
}
</code></pre>

<h2 id="step-4-create-a-service-a-name-awscli-create-service-a">Step 4: Create a Service<a name="AWSCLI_create_service"></a></h2>

<p>After you have registered a task for your account, you can create a service for the registered task in your cluster. For this example, you create a service where at least two instances of the <code>sample-fargate:1</code> task definition are kept running in your cluster.</p>

<pre><code>aws ecs create-service --cluster fargate-cluster --service-name fargate-service --task-definition sample-fargate:1 --desired-count 2 --launch-type &quot;FARGATE&quot; --network-configuration &quot;awsvpcConfiguration={subnets=[subnet-abcd1234],securityGroups=[sg-abcd1234]}&quot;
</code></pre>

<p>Output:</p>

<pre><code>{
    &quot;service&quot;: {
        &quot;status&quot;: &quot;ACTIVE&quot;, 
        &quot;taskDefinition&quot;: &quot;arn:aws:ecs:region:aws_account_id:task-definition/sample-fargate:1&quot;, 
        &quot;pendingCount&quot;: 0, 
        &quot;launchType&quot;: &quot;FARGATE&quot;, 
        &quot;loadBalancers&quot;: [], 
        &quot;roleArn&quot;: &quot;arn:aws:iam::aws_account_id:role/aws-service-role/ecs.amazonaws.com/AWSServiceRoleForECS&quot;, 
        &quot;placementConstraints&quot;: [], 
        &quot;createdAt&quot;: 1510811361.128, 
        &quot;desiredCount&quot;: 2, 
        &quot;networkConfiguration&quot;: {
            &quot;awsvpcConfiguration&quot;: {
                &quot;subnets&quot;: [
                    &quot;subnet-abcd1234&quot;
                ], 
                &quot;securityGroups&quot;: [
                    &quot;sg-abcd1234&quot;
                ], 
                &quot;assignPublicIp&quot;: &quot;DISABLED&quot;
            }
        }, 
        &quot;platformVersion&quot;: &quot;LATEST&quot;, 
        &quot;serviceName&quot;: &quot;fargate-service&quot;, 
        &quot;clusterArn&quot;: &quot;arn:aws:ecs:region:aws_account_id:cluster/fargate-cluster&quot;, 
        &quot;serviceArn&quot;: &quot;arn:aws:ecs:region:aws_account_id:service/fargate-service&quot;, 
        &quot;deploymentConfiguration&quot;: {
            &quot;maximumPercent&quot;: 200, 
            &quot;minimumHealthyPercent&quot;: 100
        }, 
        &quot;deployments&quot;: [
            {
                &quot;status&quot;: &quot;PRIMARY&quot;, 
                &quot;networkConfiguration&quot;: {
                    &quot;awsvpcConfiguration&quot;: {
                        &quot;subnets&quot;: [
                            &quot;subnet-abcd1234&quot;
                        ], 
                        &quot;securityGroups&quot;: [
                            &quot;sg-abcd1234&quot;
                        ], 
                        &quot;assignPublicIp&quot;: &quot;DISABLED&quot;
                    }
                }, 
                &quot;pendingCount&quot;: 0, 
                &quot;launchType&quot;: &quot;FARGATE&quot;, 
                &quot;createdAt&quot;: 1510811361.128, 
                &quot;desiredCount&quot;: 2, 
                &quot;taskDefinition&quot;: &quot;arn:aws:ecs:region:aws_account_id:task-definition/sample-fargate:1&quot;, 
                &quot;updatedAt&quot;: 1510811361.128, 
                &quot;platformVersion&quot;: &quot;0.0.1&quot;, 
                &quot;id&quot;: &quot;ecs-svc/9223370526043414679&quot;, 
                &quot;runningCount&quot;: 0
            }
        ], 
        &quot;events&quot;: [], 
        &quot;runningCount&quot;: 0, 
        &quot;placementStrategy&quot;: []
    }
}
</code></pre>

<h2 id="step-5-list-services-a-name-awscli-list-services-a">Step 5: List Services<a name="AWSCLI_list_services"></a></h2>

<p>List the services for your cluster. You should see the service that you created in the previous section. You can take the service name or the full ARN that is returned from this command and use it to describe the service later.</p>

<pre><code>aws ecs list-services --cluster fargate-cluster
</code></pre>

<p>Output:</p>

<pre><code>{
    &quot;serviceArns&quot;: [
        &quot;arn:aws:ecs:region:aws_account_id:service/fargate-service&quot;
    ]
}
</code></pre>

<h2 id="step-6-describe-the-running-service-a-name-awscli-describe-service-a">Step 6: Describe the Running Service<a name="AWSCLI_describe_service"></a></h2>

<p>Describe the service using the service name retrieved earlier to get more information about the task.</p>

<pre><code>aws ecs describe-services --cluster fargate-cluster --services fargate-service
</code></pre>

<p>Output:</p>

<pre><code>{
    &quot;services&quot;: [
        {
            &quot;status&quot;: &quot;ACTIVE&quot;, 
            &quot;taskDefinition&quot;: &quot;arn:aws:ecs:region:aws_account_id:task-definition/sample-fargate:1&quot;, 
            &quot;pendingCount&quot;: 2, 
            &quot;launchType&quot;: &quot;FARGATE&quot;, 
            &quot;loadBalancers&quot;: [], 
            &quot;roleArn&quot;: &quot;arn:aws:iam::aws_account_id:role/aws-service-role/ecs.amazonaws.com/AWSServiceRoleForECS&quot;, 
            &quot;placementConstraints&quot;: [], 
            &quot;createdAt&quot;: 1510811361.128, 
            &quot;desiredCount&quot;: 2, 
            &quot;networkConfiguration&quot;: {
                &quot;awsvpcConfiguration&quot;: {
                    &quot;subnets&quot;: [
                        &quot;subnet-abcd1234&quot;
                    ], 
                    &quot;securityGroups&quot;: [
                        &quot;sg-abcd1234&quot;
                    ], 
                    &quot;assignPublicIp&quot;: &quot;DISABLED&quot;
                }
            }, 
            &quot;platformVersion&quot;: &quot;LATEST&quot;, 
            &quot;serviceName&quot;: &quot;fargate-service&quot;, 
            &quot;clusterArn&quot;: &quot;arn:aws:ecs:region:aws_account_id:cluster/fargate-cluster&quot;, 
            &quot;serviceArn&quot;: &quot;arn:aws:ecs:region:aws_account_id:service/fargate-service&quot;, 
            &quot;deploymentConfiguration&quot;: {
                &quot;maximumPercent&quot;: 200, 
                &quot;minimumHealthyPercent&quot;: 100
            }, 
            &quot;deployments&quot;: [
                {
                    &quot;status&quot;: &quot;PRIMARY&quot;, 
                    &quot;networkConfiguration&quot;: {
                        &quot;awsvpcConfiguration&quot;: {
                            &quot;subnets&quot;: [
                                &quot;subnet-abcd1234&quot;
                            ], 
                            &quot;securityGroups&quot;: [
                                &quot;sg-abcd1234&quot;
                            ], 
                            &quot;assignPublicIp&quot;: &quot;DISABLED&quot;
                        }
                    }, 
                    &quot;pendingCount&quot;: 2, 
                    &quot;launchType&quot;: &quot;FARGATE&quot;, 
                    &quot;createdAt&quot;: 1510811361.128, 
                    &quot;desiredCount&quot;: 2, 
                    &quot;taskDefinition&quot;: &quot;arn:aws:ecs:region:aws_account_id:task-definition/sample-fargate:1&quot;, 
                    &quot;updatedAt&quot;: 1510811361.128, 
                    &quot;platformVersion&quot;: &quot;0.0.1&quot;, 
                    &quot;id&quot;: &quot;ecs-svc/9223370526043414679&quot;, 
                    &quot;runningCount&quot;: 0
                }
            ], 
            &quot;events&quot;: [
                {
                    &quot;message&quot;: &quot;(service fargate-service) has started 2 tasks: (task 53c0de40-ea3b-489f-a352-623bf1235f08) (task d0aec985-901b-488f-9fb4-61b991b332a3).&quot;, 
                    &quot;id&quot;: &quot;92b8443e-67fb-4886-880c-07e73383ea83&quot;, 
                    &quot;createdAt&quot;: 1510811841.408
                }, 
                {
                    &quot;message&quot;: &quot;(service fargate-service) has started 2 tasks: (task b4911bee-7203-4113-99d4-e89ba457c626) (task cc5853e3-6e2d-4678-8312-74f8a7d76474).&quot;, 
                    &quot;id&quot;: &quot;d85c6ec6-a693-43b3-904a-a997e1fc844d&quot;, 
                    &quot;createdAt&quot;: 1510811601.938
                }, 
                {
                    &quot;message&quot;: &quot;(service fargate-service) has started 2 tasks: (task cba86182-52bf-42d7-9df8-b744699e6cfc) (task f4c1ad74-a5c6-4620-90cf-2aff118df5fc).&quot;, 
                    &quot;id&quot;: &quot;095703e1-0ca3-4379-a7c8-c0f1b8b95ace&quot;, 
                    &quot;createdAt&quot;: 1510811364.691
                }
            ], 
            &quot;runningCount&quot;: 0, 
            &quot;placementStrategy&quot;: []
        }
    ], 
    &quot;failures&quot;: []
}
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>AWS ECS Streategy</title>
            <link>/posts/first/</link>
            <pubDate>Sun, 02 Oct 2016 22:55:05 -0400</pubDate>
            
            <guid>/posts/first/</guid>
            <description>Amazon Elastic Container Service (ECS) is a highly scalable, high-performance container orchestration service that allows you to easily run and scale containerized applications on AWS. This post covers how Amazon Elastic Container Service (Amazon ECS) runs containers in a cluster with the EC2 launch type. Topics include why AWS built the task placement engine, the different strategies and constraints available to decide where and how containers are run, and things to consider when picking placement strategies.</description>
            <content type="html"><![CDATA[

<p><a href="https://aws.amazon.com/ecs/">Amazon Elastic Container Service (ECS</a>) is a highly scalable, high-performance container orchestration service that allows you to easily run and scale containerized applications on AWS. This post covers how  <a href="https://aws.amazon.com/ecs/">Amazon Elastic Container Service (Amazon ECS</a>) runs containers in a cluster with the EC2 launch type. Topics include why AWS built the task placement engine, the different strategies and constraints available to decide where and how containers are run, and things to consider when picking placement strategies.</p>

<p>If you are not familiar with the relationship between ECS and Amazon EC2 or its components, see the  <a href="http://aws.amazon.com/blogs/compute/building-blocks-of-amazon-ecs/">Building Blocks of Amazon ECS</a>  post.</p>

<p><img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2019/01/03/taskplacement-ec2-instance.png" alt="Task Placement" /></p>

<p>When a task is launched in a cluster, a decision has to be made to choose which container instance should run that task. Conversely, when scaling down a service, a decision has to be made to choose the specific task to be terminated.</p>

<h3 id="task-placement">Task placement</h3>

<p>By default, ECS uses the following placement strategies:</p>

<ul>
<li>When you run tasks with the  <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html">RunTask</a>  API action, tasks are placed randomly in a cluster.</li>
<li>When you launch and terminate tasks with the  <a href="http://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateService.html">CreateService</a>  API action, the service scheduler spreads the tasks across the Availability Zones (and the instances within the zones) in a cluster.</li>
</ul>

<p>Before December 2016, tasks could only be placed by their default placement strategies. This meant making the decision yourself, such as writing your own scheduler, and calling the  <a href="http://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_StartTask.html">StartTask</a>  API action to achieve custom task placement. When you manually constrained the placement of your grouping of containers, you could only place based on CPU, memory, and ports. Additionally, while creating your own scheduler can be powerful, there’s a tradeoff with complexity.</p>

<p>AWS built the task placement engine, which removes the need for you to build, run, and manage your own scheduling and placement services. There are several new features that provide you with more control over how applications run across clusters through custom attributes.</p>

<p>You can think of this flow as a funnel with filters for your instances. Constraints must be obeyed. If an instance doesn’t fit, it isn’t used. Strategies are then used to sort the rest of the instances by preference to determine which are the “best.”</p>

<p>For every instantiation of your task, it runs through every step. Calling  <em>run-task</em>  with a count of  <em>n</em>  is effectively calling  <em>run-task n</em>  times (<em>create-service</em>  also works the same way).</p>

<p><img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2019/01/17/taskplacement-filter-final.png" alt="Cluster constraints, placement constraints, placement strategies" /></p>

<h3 id="example">Example</h3>

<p>Here’s how to use these placement features. In this example, you use the  <a href="https://aws.amazon.com/cli/">AWS CLI</a>  <em>run-task</em>  command. For the last couple of filters, I show how to use them with placement flags, but you can just as easily include them in your task definition file instead. This can all be done in the console as well. Start with the cluster shown earlier:</p>

<p><img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2019/01/03/taskplacement-cpufilter-blank.png" alt="Task Placement Instances" /></p>

<pre><code class="language-bash">aws ecs run-task --task-definition nouvelleApp \
--placement-constraints type=&quot;memberOf&quot;,expression=&quot;attribute:ecs.instance-type == t2.small&quot; \
--placement-strategy --placement-strategy type=&quot;binpack&quot;,field=&quot;memory&quot; \
--count 8
</code></pre>

<h4 id="cluster-constraints">Cluster constraints</h4>

<p>In the first step, eliminate all the instances that don’t have the required resources based on what you defined either in the JSON  <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html">task definition</a>  or what you provided overrides for to RunTask.</p>

<p>Not enough CPU? Not enough memory? A port is needed, but it is already in use on that instance? Then the instance is eliminated from the set of valid candidates.</p>

<p><img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2019/01/03/taskplacement-cpufilter.png" alt="Task Placement Cluster Constraints" /></p>

<pre><code class="language-bash">aws ecs run-task --task-definition nouvelleApp
</code></pre>

<h4 id="placement-constraints">Placement constraints</h4>

<p>In the second step, keep only the instances that satisfy the  <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-constraints.html#attributes">attribute</a>  or  <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-constraints.html#task-groups">task group</a>  constraints. Yes, this means that you can indicate what instance to use for a task (for example, to make sure that CPU-intensive jobs are scheduled on the right type of instance, or in which Availability Zone).</p>

<p>You can also create any custom tags of your choosing. The green tasks on the green instances, the blue tasks on the blue instances! You can also use the  <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html">Cluster Query Language</a>  to write expressions to check for multiple attributes. In the next section, I cover how to write and use the attributes and expressions.</p>

<p><img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2019/01/03/taskplacement-1-placement-const.png" alt="Placement Constraints" /></p>

<pre><code class="language-bash">--placement-constraints type=&quot;memberOf&quot;,expression=&quot;attribute:ecs.instance-type == t2.micro&quot;
</code></pre>

<h4 id="placement-strategies">Placement strategies</h4>

<p>In the third step, filter on the following supported task placement strategies:</p>

<ul>
<li><code>random</code></li>
<li><code>binpack</code></li>
<li><code>spread</code></li>
</ul>

<p>By default, tasks are randomly placed with RunTask or spread across Availability Zones with CreateService. Spread is typically used to achieve high availability by making sure that multiple copies of a task are scheduled across multiple instances based on attributes such as Availability Zones.</p>

<p>Conversely, binpack places tasks together to be as cost-efficient as possible. Later in this post, you’ll see how these placement strategies work, as well as how to chain them together and why you may want to do so.</p>

<p><img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2019/01/03/taskplacement-1-placement-binpack.png" alt="Task Placement Binpack" /></p>

<pre><code class="language-bash">--placement-strategy type=&quot;binpack&quot;,field=&quot;memory&quot;
</code></pre>

<h4 id="task-copies">Task copies</h4>

<p>This isn’t part of the filter, but instead, the  <em>count</em>  flag is used to indicate how many copies (<em>n</em>) of a given task to run. Effectively, it tells ECS to re-run this workflow  <em>n</em>  times. By default, the count is set to 1, so  <em>run-task</em>  is executed one time. For services, the  <em>desired-count</em>  flag is used.</p>

<pre><code class="language-bash">--count 8
</code></pre>

<h2 id="attributes-task-groups-and-expressions">Attributes, task groups, and expressions</h2>

<p>For task placement, you can use instance fields, such as attributes, as well as task groups. These can be used in expressions for task placement constraints, or instance fields can be used standalone for task placement strategies. Here’s a quick overview of  <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-constraints.html">attributes, task groups, and expressions</a>  before you go any further.</p>

<h3 id="instance-fields">Instance: Fields</h3>

<p>Because you are using these fields with respect to instances in task placement, the  <em>instance:</em>  preface is optional and can be used either of the following ways with a field name or an attribute.</p>

<pre><code class="language-bash">instance:&lt;field&gt;
&lt;field&gt;
</code></pre>

<h4 id="field-names">Field names</h4>

<p>The currently supported field names are as follows:</p>

<pre><code class="language-bash">ec2InstanceId
agentConnected
</code></pre>

<h3 id="attributes">Attributes</h3>

<p>There are also instance attributes, which are prefaced with  <em>attribute</em>. Again,  <em>instance:</em>  is optional:</p>

<pre><code class="language-bash">attribute:&lt;attribute-name&gt;
</code></pre>

<h4 id="built-in-attributes">Built-in attributes</h4>

<p>The following are some of the provided  <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-constraints.html#attributes">attributes</a>:</p>

<pre><code class="language-bash">ecs.ami-id
ecs.availability-zone
ecs.instance-type
ecs.os-type
ecs.subnet-id
ecs.vpc-id
</code></pre>

<h4 id="custom-attributes">Custom attributes</h4>

<p>Well, what if you don’t see an attribute that you want? This is where  <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-constraints.html#attributes">custom attributes</a>  come in handy! Want to differentiate between test and prod? What about blue versus green?</p>

<pre><code class="language-bash">aws ecs put-attributes \
--attributes name=color,value=blue,targetId=&lt;your-container-instance-arn&gt;
</code></pre>

<h3 id="task-groups">Task groups</h3>

<p>In addition to placing tasks based on attributes, you can use  <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-constraints.html#task-groups">task groups</a>. Every task is assigned a group ID that you can reference in placement. For both tasks and services, a default ID is given, or you can choose your own. Perhaps you want to run version 2 of a service but only on instances with version 1.</p>

<pre><code class="language-bash">task:group
</code></pre>

<h3 id="expressions">Expressions</h3>

<p>Alright, so you have some attributes and task groups… now what? Well, AWS created the  <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html">Cluster Query Language</a>  to make it easy to create expressions for task placement constraints. These attributes and task groups are used with the available  <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html">comparison operators</a>, which may look familiar if you’ve used Boolean operators before. Some of these operators can be written in multiple ways, such as “!” or “not”.</p>

<p>For instance, to create an expression using a single attribute to select only  <em>t2.micro</em>  instances, use the  _ecs.instance-type_attribute and the string equality comparator as follows:</p>

<pre><code class="language-bash">attribute:ecs.instance-type == t2.micro
</code></pre>

<p>For  <em>t2.micro</em>  and  <em>t2.nano</em>  instances, you have a few options. You could use the same syntax as earlier with the  <em>or</em> comparator:</p>

<pre><code class="language-bash">attribute:ecs.instance-type == t2.micro or attribute:ecs.instance-type == t2.nano
</code></pre>

<p>Another way is to use the  <em>in</em>  comparator with an argument list:</p>

<pre><code class="language-bash">attribute:ecs.instance-type in [t2.micro, t2.nano]
</code></pre>

<p>To include all t2 instances, use a wildcard and the pattern match operator instead of listing out each one:</p>

<pre><code class="language-bash">attribute:ecs.instance-type =~ t2.*
</code></pre>

<p>Task group comparisons work the same way. The following snippet selects any instance upon which the task group “database” is running:</p>

<pre><code class="language-bash">task:group == database
</code></pre>

<p>To select only task groups that are not “database,” combine expressions:</p>

<pre><code class="language-bash">not(task:group == database)
</code></pre>

<p>You can use these expressions to filter your instances:</p>

<pre><code class="language-bash">aws ecs list-container-instances \
--filter &quot;attribute:ecs.instance-type != t2.micro&quot;
aws ecs list-container-instances \
--filter &quot;attribute:color == blue&quot;
aws ecs list-container-instances \
--filter &quot;task:group == database&quot;
</code></pre>

<p>These expressions and attributes, respectively, are also used for task placement constraints and strategies, which I cover in the next few sections.</p>

<h2 id="constraints">Constraints</h2>

<p>Now look at placement constraints. When determining task placement, there may be certain EC2 instances to include or exclude from running containers. For example, you may want to place tasks only on GPU types.</p>

<p>Task placement constraints let you define where your containers should run across your cluster. ECS currently supports two types of placement constraints:  <em>distinctInstance</em>  and  <em>memberOf</em>. By default, ECS spreads tasks across Availability Zones and instances.</p>

<pre><code class="language-bash">  &quot;placementConstraints&quot;: [ 
      { 
         &quot;expression&quot;: &quot;string&quot;,
         &quot;type&quot;: &quot;string&quot;
      }
   ],
</code></pre>

<h3 id="distinct-instance">Distinct Instance</h3>

<p><img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2019/01/03/taskplacement-3-distinctinstance.png" alt="Distinct Instance" />The  <em>distinctInstance</em>  constraint makes it possible to ensure that every container is started on a unique instance in your cluster. The distinctInstance constraint never places multiple copies of a task on a single instance, even if you request more running tasks than available instances.</p>

<p>For example if you decide to place five copies of a task, each time it filters out the instances that are already running the task.</p>

<pre><code class="language-bash">aws ecs run-task --task-definition nouvelleApp \
--count 5 --placement-constraints type=&quot;distinctInstance&quot;
</code></pre>

<h3 id="member-of">Member of</h3>

<p><strong><img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2019/01/03/taskplacement-3-placement-member-of-t2micro.png" alt="Member of t2-micro" /></strong> The  <em>memberOf</em> constraint describes a set of instances on which your tasks should run. It is for anything you could define as an attribute or task<strong>.</strong> It also takes in an expression of attributes written in the  <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html">Cluster Query Language</a>.</p>

<p>For example, if you have a small application and just want it to run on  <em>t2.micro</em>  instances:</p>

<pre><code class="language-bash">aws ecs run-task --task-definition nouvelleApp \
--count 5 \
--placement-constraints 
type=&quot;memberOf&quot;,expression=&quot;attribute:ecs.instance-type == t2.micro&quot;
</code></pre>

<p>You can create expressions using the Cluster Query Language to check for multiple attributes. Here’s how you can weed out all instances in the  <em>us-west-2c</em>  Availability Zone as well as instances that aren’t of type  <em>t2.nano</em>  or  <em>t2.micro</em>:</p>

<pre><code class="language-bash">aws ecs run-task --task-definition nouvelleApp \
--count 5 \
--placement-constraints type=&quot;memberOf&quot;,expression=&quot;attribute:ecs.availability-zone != us-west-2c and (attribute:ecs.instance-type == t2.nano or attribute:ecs.instance-type == t2.micro)&quot;
</code></pre>

<p><img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2019/01/03/taskplacement-3-placement-member-of-affinity.png" alt="Member of affinity" /></p>

<p>You can also use constraints to place all tasks with the same task group on the same instance (affinity):</p>

<pre><code class="language-bash">aws ecs run-task --task-definition nouvelleApp \
--count 5 --group webserver \
--placement-constraints type=memberOf,expression=&quot;task:group == webserver&quot;
</code></pre>

<p>Or you can ensure that instances never have more than one task in the same group (anti-affinity):</p>

<p>aws ecs run-task –task-definition nouvelleApp –count 5 –group webserver –placement-constraints type=memberOf,expression=”not(task:group == webserver)”</p>

<h2 id="strategies">Strategies</h2>

<p>Now look at placement strategies. Placement strategies are used to identify an instance that meets a specific strategy. ECS supports three task placement strategies:</p>

<ul>
<li><code>random</code></li>
<li><code>binpack</code></li>
<li><code>spread</code></li>
</ul>

<p>Random is how RunTask places tasks by default and is fairly straightforward (it doesn’t require further parameters). The two other strategies, binpack and spread, take opposite actions. Binpack places tasks on as few instances as possible, helping to optimize resource utilization, while spread places tasks evenly across your cluster to help maximize availability. By default, ECS uses spread with the  <em>ecs.availability-zone</em>  attribute to place tasks.</p>

<pre><code class="language-bash">   &quot;placementStrategy&quot;: [ 
      { 
         &quot;field&quot;: &quot;string&quot;,
         &quot;type&quot;: &quot;string&quot;
      }
   ],
</code></pre>

<h3 id="random">Random</h3>

<p><img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2019/01/03/taskplacement-4-random.png" alt="Placement Random" /></p>

<p>Random places tasks on instances at random. This still honors the other constraints that you specified, implicitly or explicitly. Specifically, it still makes sure that tasks are scheduled on instances with enough resources to run them.</p>

<pre><code class="language-bash">aws ecs run-task --task-definition nouvelleApp \
--count 5 \
--placement-strategy type=&quot;random&quot;
</code></pre>

<h3 id="bin-packing">Bin packing</h3>

<p><img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2019/01/03/taskplacement-4-binpack.png" alt="Placement Binpack" /></p>

<p>The binpack strategy tries to fit your workloads in as few instances as possible. It gets its name from the  <a href="https://en.wikipedia.org/wiki/Bin_packing_problem">bin packing problem</a>  where the goal is to fit objects of various sizes in the smallest number of bins. It is well suited to scenarios for minimizing the number of instances in your cluster, perhaps for cost savings, and lends itself well to automatic scaling for elastic workloads, to shut down instances that are not in use.</p>

<p>When you use the binpack strategy, you must also indicate if you are trying to make optimal use of your instances’ CPU or memory. This is done by passing an extra  <em>field</em>  parameter, which tells the task placement engine which parameter to use to evaluate how “full” your “bins” are. It then chooses the instance with the least available CPU or memory (depending on which you pick). If there are multiple instances with this CPU or memory remaining, it chooses randomly.</p>

<pre><code class="language-bash">aws ecs run-task --task-definition nouvelleApp \
--count 8 --placement-strategy type=&quot;binpack&quot;,field=&quot;cpu&quot;

aws ecs run-task --task-definition nouvelleApp \
--count 8 --placement-strategy type=&quot;binpack&quot;,field=&quot;memory&quot;
</code></pre>

<h3 id="spread">Spread</h3>

<p><img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2019/01/03/taskplacement-4-spread.png" alt="Placement Spread" /></p>

<p>The spread strategy, contrary to the binpack strategy, tries to put your tasks on as many different instances as possible. It is typically used to achieve high availability and mitigate risks, by making sure that you don’t put all your task-eggs in the same instance-baskets. Spread across Availability Zones, therefore, is the default placement strategy used for services.</p>

<p>When using the spread strategy, you must also indicate a  <em>field</em> parameter. It is used to indicate the “bins” that you are considering. The accepted values are  <em>instanceID</em>  to balance tasks across all instances,  <em>host</em>, or attribute key:value pairs such as  <em>attribute:ecs.availability-zone</em>  to balance tasks across zones. There are several AWS attributes that start with the “ecs” prefix, but you can be creative and create your own attributes.</p>

<pre><code class="language-bash">aws ecs run-task --task-definition nouvelleApp \
--count 8 \
--placement-strategy type=&quot;spread&quot;,field=&quot;attribute:ecs.availability-zone&quot;
</code></pre>

<h2 id="chaining-placement-strategies">Chaining placement strategies</h2>

<p><img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2019/01/03/taskplacement-1-placement-binpackspreadaz.png" alt="Placement binpack spread" /></p>

<p>Now that you’ve seen how to use task placement strategies, you can also chain multiple task placement strategies with their respective attributes together. You can have up to five strategy rules per service. Perhaps you want to spread tasks across Availability Zones and binpack:</p>

<pre><code class="language-bash">aws ecs run-task --task-definition nouvelleApp \
--count 8 \
--placement-strategy type=&quot;spread&quot;,field=&quot;attribute:ecs.availability-zone&quot; type=&quot;binpack&quot;,field=&quot;memory&quot;
</code></pre>

<h2 id="use-cases">Use cases</h2>

<p>Here are some use cases for task placement so you can see how they can be solved by combining attributes, expressions, constraints, and strategies.</p>

<h4 id="task-creation">Task creation</h4>

<p>Mariya is fairly new to using containers and especially container orchestrators. She wants to try ECS and has a simple application that she first wants to get running on a single node. (Solution: Use the RunTask API.)</p>

<pre><code class="language-bash">aws ecs run-task --task-definition nouvelleApp
</code></pre>

<h4 id="scaling">Scaling</h4>

<p>After trying this, Mariya wants to scale her application to run 10 containers across any available nodes in her cluster. (Solution: This means she needs to run a task using either random or spread placement strategies.)</p>

<pre><code class="language-bash">aws ecs run-task --task-definition nouvelleApp \
--count 10 \
--placement-strategy type=&quot;random&quot;
</code></pre>

<h4 id="availability">Availability</h4>

<p>Mariya then realizes that if she wants her tasks to automatically restart themselves if they fail, or if she wants more than 10 instantiations of her task running, she needs to create a service. (Solution: Create a service.)</p>

<pre><code class="language-bash">aws ecs create-service --task-definition nouvelleApp \
--desiredCount 300 --placement-strategy type=&quot;random&quot;
</code></pre>

<p>Christopher wants to achieve high availability by distributing his tasks amongst all the instances in his cluster so he minimizes impact if any one host goes down. (Solution: To do this he uses spread placement over host name.)</p>

<pre><code class="language-bash">aws ecs run-task --task-definition nouvelleApp \
--count 9 \
--placement-strategy type=&quot;spread&quot;,field=&quot;host&quot;
</code></pre>

<p>Ming-ya wants to run a monitoring container on each instance in her cluster. To help her do this, she creates a service with a high desired count and a  <em>distinctInstance</em>  placement constraint. The ECS service scheduler ensures that each instance in the cluster runs this task (up to the desired count).</p>

<pre><code class="language-bash">aws ecs create-service --service-name monitoring \
--task-definition monitor \
--desiredCount 500 \
--placement-constraints type=&quot;distinctInstance&quot;
</code></pre>

<h4 id="availability-and-task-groups">Availability and Task Groups</h4>

<p>Alex wants to run a fleet of webservers. For performance reasons, they want each webserver to have local access to a caching process that was written by another team. They define their webserver as one task, the caching server as a second task. When they launch their webserver task they uses a placement constraint so that the tasks are only placed on instances that are already hosting the cache task. (Solution: Use placement constraints with a task group.)</p>

<pre><code class="language-bash">aws ecs run-task --task-definition cache \
--group caching --count 9 \
--placement-constraints type=&quot;distinctInstance&quot;

aws ecs run-task --task-definition webserver \
--count 9 \
--placement-constraints type=&quot;distinctInstance&quot; type=&quot;memberOf&quot;,expression=&quot;task:group == caching&quot;
</code></pre>

<h4 id="availability-and-resource-optimization">Availability and resource optimization</h4>

<p>Jake wants to achieve high availability, but he has a limited budget and needs to optimize all the resources he uses. (Solution: Take a balanced approach of spreading over availability Availability Zones and binpacking on memory within a zone.)</p>

<pre><code class="language-bash">aws ecs run-task --task-definition nouvelleApp \
--count 9 \
--placement-strategy type=&quot;spread&quot;,field=&quot;attribute:ecs.availability-zone&quot; type=&quot;binpack&quot;,field=&quot;memory&quot;
</code></pre>

<h4 id="instance-type-selection">Instance type selection</h4>

<p>Aditya has a GPU workload that they want to run in containers on ECS. He needs to ensure that only GPU-enabled instances are used for this workload. (Solution: Create a service and spread on instance type = G2* or whatever other GPU-enabled instance types are in the cluster)</p>

<pre><code class="language-bash">aws ecs create-service --service-name workload \
--task-definition GPU --desiredCount 30 \
--placement-constraints type=&quot;memberOf&quot;,expression=&quot;attribute:ecs.instance-type =~ g2* or attribute:ecs.instance-type =~ p2*&quot;
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve now looked at task placement at a high level, as well as:</p>

<ul>
<li>Attributes, task groups, and expressions</li>
<li>Constraints</li>
<li>Strategies</li>
<li>Example use cases</li>
</ul>

<p>To dive deeper into any of these aspects, check out  <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement.html">Task Placement</a>. Also, feel free to ask any questions!</p>

<p><a href="https://twitter.com/tiffanyfayj"><img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2018/01/24/twitter-icon-8-15x15.png" alt="" /></a><a href="https://twitter.com/tiffanyfayj">@tiffanyfayj</a></p>

<p>TAGS:  <a href="https://aws.amazon.com/blogs/compute/tag/amazon-ecs/">Amazon ECS</a>,  <a href="https://aws.amazon.com/blogs/compute/tag/containers/">Containers</a>,  <a href="https://aws.amazon.com/blogs/compute/tag/docker/">Docker</a>,  <a href="https://aws.amazon.com/blogs/compute/tag/ecs/">ECS</a></p>

<p><a href="https://commenting.awsblogs.com/embed.html?disqus_shortname=aws-compute&amp;disqus_identifier=5567&amp;disqus_title=Amazon+ECS+Task+Placement&amp;disqus_url=https://aws.amazon.com/blogs/compute/amazon-ecs-task-placement/">View Comments</a></p>

<p><a href="https://aws.amazon.com/podcasts/aws-podcast/?sc_icampaign=aware_aws-podcast&amp;sc_ichannel=ha&amp;sc_icontent=awssm-2021&amp;sc_iplace=tile&amp;trk=ha_awssm-2021"><br />
</a></p>
]]></content>
        </item>
        
    </channel>
</rss>
